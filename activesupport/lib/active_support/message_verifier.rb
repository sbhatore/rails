require 'active_support/core_ext/hash/keys'
require 'base64'
require 'active_support/core_ext/object/blank'
require 'active_support/security_utils'
require 'active_support/claims'

module ActiveSupport
  # +MessageVerifier+ makes it easy to generate and verify messages which are
  # signed to prevent tampering.
  #
  # This is useful for cases like remember-me tokens and auto-unsubscribe links
  # where the session store isn't suitable or available.
  #
  # Remember Me:
  #   cookies[:remember_me] = @verifier.generate(@user.id, expires_at: 2.weeks.from_now, for: 'remember_me')
  #
  # In the authentication filter:
  #
  #   id = @verifier.verify(cookies[:remember_me], for: 'remember_me')
  #   self.current_user = User.find(id) if id
  #
  # By default it uses Marshal to serialize the message. If you want to use
  # another serialization method, you can set the serializer in the options
  # hash upon initialization:
  #
  #   @verifier = ActiveSupport::MessageVerifier.new('s3Krit', serializer: YAML)
  class MessageVerifier
    class InvalidSignature < StandardError; end

    def initialize(secret, options = {})
      raise ArgumentError, 'Secret should not be nil.' unless secret
      @secret = secret
      @digest = options[:digest] || 'SHA1'
      @serializer = options[:serializer] || Marshal
    end

    # Checks if a signed message could have been generated by signing an object
    # with the +MessageVerifier+'s secret.
    #
    #   verifier = ActiveSupport::MessageVerifier.new 's3Krit'
    #   signed_message = verifier.generate 'a private message'
    #   verifier.valid_message?(signed_message) # => true
    #
    #   tampered_message = signed_message.chop # editing the message invalidates the signature
    #   verifier.valid_message?(tampered_message) # => false
    def valid_message?(signed_message)
      return if signed_message.nil? || !signed_message.valid_encoding? || signed_message.blank?

      parts = signed_message.split('.')
      parts.size == 3 && parts.all?(&:present?) && untampered?(parts.pop, parts.join('.'))
    end

    # Decodes the signed message using the +MessageVerifier+'s secret. It also decodes
    # legacy signed messages which are outdated messages generated by +MessageVerifier+
    # of the previous rails version.
    #
    #   verifier = ActiveSupport::MessageVerifier.new 's3Krit'
    #
    #   signed_message = verifier.generate('a private message', for: 'test', expires_at: 1.day.from_now)
    #   verifier.verified(signed_message) # => 'a private message'
    #
    # Returns +nil+ if the message was not signed with the same secret.
    #
    #   other_verifier = ActiveSupport::MessageVerifier.new 'd1ff3r3nt-s3Krit'
    #   other_verifier.verified(signed_message) # => nil
    #
    # Returns +nil+ if the message is not Base64-encoded.
    #
    #   invalid_message = "header.claims.MTkwMmI3MzY0MDA4NDM2MzVmYjgwMGEzOTJjOGQ2ZDM2Y2VhYjZiYg=="
    #   verifier.verified(invalid_message) # => nil
    #
    # Returns +nil+ if the message doesn't have the same purpose as that
    # given in +options+.
    #
    #   verifier.verified(signed_message, for: 'something_else') # => nil
    #
    # Returns +nil+ if the message is expired.
    #
    #   expired_message = verifier.generate('a private message', expires_at: 1.day.ago)
    #   verifier.verified(expired_message) # => nil
    #
    # Raises any error raised while decoding the signed message.
    #
    #   incompatible_message = "aGVhZGVy.Y2xhaW1z.OWYzY2Y1Mzc1MmUxNjJlMzFhZDY3ODVlNGMyMTQ5YWE2OTc0NjQ5MQ=="
    #   verifier.verified(incompatible_message) # raises TypeError: incompatible marshal file format
    def verified(signed_message, options = {})
      if signed_message.include? '--'
        legacy_verifier = LegacyMessageVerifier.new(@secret, digest: @digest, serializer: @serializer)
        legacy_verifier.verify(signed_message)
      else
        return unless valid_message?(signed_message)

        Claims.verify(get_claims(signed_message), options)
      end
    rescue ArgumentError => argument_error
      raise unless argument_error.message =~ %r{invalid base64}
    end

    # Decodes the signed message using the +MessageVerifier+'s secret. It also decodes
    # legacy signed messages which are outdated messages generated by +MessageVerifier+
    # of the previous rails version.
    #
    #   verifier = ActiveSupport::MessageVerifier.new 's3Krit'
    #   signed_message = verifier.generate('a private message', for: 'test', expires_in: 1.day)
    #
    #   # Within 1 day...
    #   verifier.verify(signed_message, for: 'test') # => "a private message"
    #
    #   legacy_signed_message = "BAhJIhZhIHByaXZhdGUgbWVzc2FnZQY6BkVU--a2a1232deaf49ba164ed0d0b43b3f17cf8026c46"
    #   verifier.verify(legacy_signed_message) # => "a private message"
    #
    # Raises +InvalidSignature+ if the message was not signed with the same
    # secret or was not Base64-encoded.
    #
    #   other_verifier = ActiveSupport::MessageVerifier.new 'd1ff3r3nt-s3Krit'
    #   other_verifier.verify(signed_message) # raises ActiveSupport::MessageVerifier::InvalidSignature
    #
    # Raises +InvalidClaims+ if the message doesn't have the same purpose as that
    # given in the +options+.
    #
    #   verifier.verify(signed_message, for: 'something_else') # raises ActiveSupport::Claims::InvalidClaims
    #
    # Raises +ExpiredClaims+ if the message is expired.
    #
    #   expired_message = verifier.generate('a private message', expires_at: 1.day.ago)
    #   verifier.verify(signed_message) # raises ActiveSupport::Claims::ExpiredClaims
    def verify(signed_message, options = {})
      if value = verified(signed_message, options)
        value
      else
        unless valid_message?(signed_message) && Claims.verify!(get_claims(signed_message), options)
          raise InvalidSignature
        end
      end
    end

    # Generates a signed message for the given +value+ and +options+.
    #
    # The message is signed with the +MessageVerifier+'s secret. Without knowing
    # the secret, the original value cannot be extracted from the message. A
    # message is signed as a JSON Web Token (JWT). The final message is
    # concatenation of base64-encoded JWS header, base64-encoded JWT claims set
    # and base64-encoded signature separated by a period ('.'). This format is
    # known as a JSON Web Signature (JWS):
    # <base64-encoded header>.<base64-encoded claims>.<base64-encoded signature>
    #
    # JSON Web Token (JWT) - A string representing a set of claims as a JSON
    # object that is encoded in a JWS or JWE, enabling the claims to be
    # signed and/or encrypted.
    #
    # JWT Header - A JSON object that describes the cryptographic operations
    # applied to the JWT. When the JWT is signed, the JWT Header is a
    # JWS Header. A JWS header signed using 'SHA1' algorithm:
    #
    #   { 'typ' => 'JWT', 'alg' => 'SHA1' }
    #
    # JWT claims set - A JSON object that contains the claims conveyed by
    # the JWT. For our purpose, we limit our claims set to consist of
    # +pld+ (payload), +exp+ (expiry), and +for+ (purpose/scope). This becomes
    # the payload of JWS. For example:
    #
    #   { 'pld' => 'a private message', 'for' => 'test', 'exp' => '2015-06-29T07:16:12.579Z' }
    #
    # JWS Signature - Signature over the JWS Header and the JWS Payload (Claims set).
    # The signing input is given by ASCII(BASE64URL(UTF8(JWS Protected Header)) || '.' ||
    # BASE64URL(JWS Payload)).
    #
    # ==== Options
    #
    # * <tt>:expires_at</tt> - Explicit expiring time for the signed message.
    # * <tt>:expires_in</tt> - Relative time the message should
    #   expire after (e.g. 1.hour).
    # * <tt>:for</tt> - The signed message purpose confines usage to places with
    #   the same purpose. Defaults to a universally usable message.
    #
    # ==== Examples
    #
    # Messages can be signed to ensure that the data hasn't been tampered with.
    #
    #   verifier = ActiveSupport::MessageVerifier.new 's3Krit'
    #   verifier.generate('a private message')
    #   # => "BAh7B0kiCHR5cAY6BkVUSSIISldUBjsAVEkiCGFsZwY7AFRJIglTSEExBjsAVA==.BAh7CDoIcGxkSSIWYSBwcml2YXRlIG1lc3NhZ2UGOgZFVDoIZm9ySSIOdW5pdmVyc2FsBjsGVDoIZXhwSSIdMjAxNS0wOC0wOVQxODowNjowMy44NzhaBjsGVA==.ZmRlYjhlMTkxNGI0NGQ4OWRkNDdjZWM5YTY1NmQ3MTM5OWY5NzRmMQ=="
    #
    # Messages can be given a purpose to bump the security up some more.
    # This way evildoers can't reuse a message generated for the sign-up form
    # on any other page:
    #
    #   signup_message = verifier.generate('a private message', for: 'signup_form')
    #   # => "BAh7B0kiCHR5cAY6BkVUSSIISldUBjsAVEkiCGFsZwY7AFRJIglTSEExBjsAVA==.BAh7CDoIcGxkSSIWYSBwcml2YXRlIG1lc3NhZ2UGOgZFVDoIZm9ySSIQc2lnbnVwX2Zvcm0GOwZUOghleHBJIh0yMDE1LTA4LTA5VDE4OjA1OjEwLjM2N1oGOwZU.YTMxMzIzMDc3YTI3ZDkwM2FmNWQ1MDgwNzAxNTgwMjNjNzI2NDE0Zg=="
    #
    #   verifier.verify(signup_message, for: 'signup_form')
    #   # => 'a private message'
    #
    #   verifier.verified(signup_message, for: 'something_else') # => nil
    #
    # A message can also be given an expiration time with either +expires_in+
    # or +expires_at+. Useful when a message should not be accessible indefinitely.
    # The +expires_in+ option accepts a relative time, which is resolved to an
    # explicit expiry time, when the message is signed:
    #
    #   expiring_message = verifier.generate('a private message', for: 'remember_me', expires_in: 1.hour)
    #   # => "BAh7B0kiCHR5cAY6BkVUSSIISldUBjsAVEkiCGFsZwY7AFRJIglTSEExBjsAVA==.BAh7CDoIcGxkSSIWYSBwcml2YXRlIG1lc3NhZ2UGOgZFVDoIZm9ySSIQcmVtZW1iZXJfbWUGOwZUOghleHBJIh0yMDE1LTA3LTA5VDE5OjAzOjEwLjQ3MVoGOwZU.MmQxNzkxMmY2MGU5ZmQ2YTlhNmRhYmYyNmEzNDUzNjE0ZDdjNzg2Yw=="
    #
    #   # Within 1 hour...
    #   verifier.verify(expiring_message, for: 'remember_me')
    #   # => "a private message"
    #
    #   # After 1 hour...
    #   verifier.verify(expiring_message, for: 'remember_me')
    #   # raises ActiveSupport::Claims::ExpiredClaims
    #
    # A message can also be set to expire at an explicit time with +expires_at+:
    #
    #   expiring_message = verifier.generate('a private message', for: 'something', expires_at: Date.tomorrow.midnight)
    #   # => "BAh7B0kiCHR5cAY6BkVUSSIISldUBjsAVEkiCGFsZwY7AFRJIglTSEExBjsAVA==.BAh7CDoIcGxkSSIWYSBwcml2YXRlIG1lc3NhZ2UGOgZFVDoIZm9ySSIOc29tZXRoaW5nBjsGVDoIZXhwSSIdMjAxNS0wNy0xMVQwMDowMDowMC4wMDBaBjsGVA==.M2I2NThmOGFiNWYxMDNiNDhjNDA1NGI2YTgxOWQyYzY5ZmQyYzMzNQ=="
    #
    #   # Before the following day's midnight...
    #   verifier.verify(expiring_message, for: 'something')
    #   # => "a private message"
    #
    #   # After the following day's midnight ...
    #   verifier.verify(expiring_message, for: 'something')
    #   # raises ActiveSupport::Claims::ExpiredClaims
    def generate(value, options = {})
      @claims = Claims.new(payload: value, **options)
      data = [encode(serialized_header), encode(serialized_claims)].join('.')
      "#{data}.#{encode(generate_digest(data))}"
    end

    private
      def header
        { 'typ' => 'JWT', 'alg' => @digest.to_s }
      end

      def serialized_header
        @serializer.dump header
      end

      def serialized_claims
        @serializer.dump @claims.to_h
      end

      def get_claims(signed_message)
        @serializer.load(decode(signed_message.split('.')[1])).symbolize_keys
      end

      def encode(data)
        ::Base64.strict_encode64(data)
      end

      def decode(data)
        ::Base64.strict_decode64(data)
      end

      def untampered?(digest, data)
        ActiveSupport::SecurityUtils.secure_compare digest, encode(generate_digest(data))
      end

      def generate_digest(data)
        require 'openssl' unless defined?(OpenSSL)
        OpenSSL::HMAC.hexdigest(OpenSSL::Digest.const_get(@digest).new, @secret, data)
      end
  end

  private
    class LegacyMessageVerifier < MessageVerifier # :nodoc:
      def valid_message?(signed_message)
        return if signed_message.nil? || !signed_message.valid_encoding? || signed_message.blank?
                
        data, digest = signed_message.split("--")
        data.present? && digest.present? && ActiveSupport::SecurityUtils.secure_compare(digest, generate_digest(data))
      end

      def verified(signed_message)
        return unless valid_message?(signed_message)

        data = signed_message.split("--").first
        @serializer.load decode(data)
      rescue ArgumentError => argument_error
        return if argument_error.message =~ %r{invalid base64}
        raise
      end

      def verify(signed_message)
        verified(signed_message) || raise(InvalidSignature)
      end

      def generate(value)
        data = encode(@serializer.dump(value))
        "#{data}--#{generate_digest(data)}"
      end
    end
end
