require 'active_support/core_ext/hash/keys'
require 'base64'
require 'active_support/core_ext/object/blank'
require 'active_support/security_utils'
require 'active_support/claims'

module ActiveSupport
  # +MessageVerifier+ makes it easy to generate and verify messages which are
  # signed to prevent tampering.
  #
  # This is useful for cases like remember-me tokens and auto-unsubscribe links
  # where the session store isn't suitable or available.
  #
  # Remember Me:
  #   cookies[:remember_me] = @verifier.generate(value: @user.id, expires_at: 2.weeks.from_now, for: 'remember_me')
  #
  # In the authentication filter:
  #
  #   id = @verifier.verify(cookies[:remember_me], for: 'remember_me')
  #   self.current_user = User.find(id) if id
  #
  # By default it uses Marshal to serialize the message. If you want to use
  # another serialization method, you can set the serializer in the options
  # hash upon initialization:
  #
  #   @verifier = ActiveSupport::MessageVerifier.new('s3Krit', serializer: YAML)
  class MessageVerifier
    class InvalidSignature < StandardError; end

    def initialize(secret, options = {})
      raise ArgumentError, 'Secret should not be nil.' unless secret
      @secret = secret
      @digest = options[:digest] || 'SHA1'
      @serializer = options[:serializer] || Marshal
    end

    # Checks if a signed message could have been generated by signing an object
    # with the +MessageVerifier+'s secret.
    #
    #   verifier = ActiveSupport::MessageVerifier.new 's3Krit'
    #   signed_message = verifier.generate 'a private message'
    #   verifier.valid_message?(signed_message) # => true
    #
    #   tampered_message = signed_message.chop # editing the message invalidates the signature
    #   verifier.valid_message?(tampered_message) # => false
    def valid_message?(signed_message)
      return if signed_message.nil? || !signed_message.valid_encoding? || signed_message.blank?

      parts = signed_message.split('.')
      parts.size == 3 && parts.all?(&:present?) && untampered?(parts.pop, parts.join('.'))
    end

    # Decodes the signed message using the +MessageVerifier+'s secret and returns the claims hash.
    #
    #   verifier = ActiveSupport::MessageVerifier.new 's3Krit'
    #
    #   signed_message = verifier.generate(value: 'a private message', for: 'test', expires_at: 1.day.from_now)
    #   verifier.verified(signed_message)
    #   # => {:pld=>"a private message", :for=>"test", :exp=>"2015-06-29T07:16:12.579Z"}
    #
    # Returns +nil+ if the message was not signed with the same secret.
    #
    #   other_verifier = ActiveSupport::MessageVerifier.new 'd1ff3r3nt-s3Krit'
    #   other_verifier.verified(signed_message) # => nil
    #
    # Returns +nil+ if the message is not Base64-encoded.
    #
    #   invalid_message = "header.claims.MTkwMmI3MzY0MDA4NDM2MzVmYjgwMGEzOTJjOGQ2ZDM2Y2VhYjZiYg=="
    #   verifier.verified(invalid_message) # => nil
    #
    # Raises any error raised while decoding the signed message.
    #
    #   incompatible_message = "aGVhZGVy.Y2xhaW1z.OWYzY2Y1Mzc1MmUxNjJlMzFhZDY3ODVlNGMyMTQ5YWE2OTc0NjQ5MQ=="
    #   verifier.verified(incompatible_message) # => TypeError: incompatible marshal file format
    def verified(signed_message)
      return unless valid_message?(signed_message)
      
      data = signed_message.split('.')[1]
      @serializer.load(decode(data)).symbolize_keys
    rescue ArgumentError => argument_error
      return if argument_error.message =~ %r{invalid base64}
      raise
    end

    # Decodes the signed message and legacy signed message using the +MessageVerifier+'s secret.
    #
    #   verifier = ActiveSupport::MessageVerifier.new 's3Krit'
    #   signed_message = verifier.generate(value: 'a private message', for: 'test', expires_in: 1.day)
    #
    #   verifier.verify(signed_message, for: 'test') # => "a private message"
    #
    #   legacy_signed_message = "BAhJIhZhIHByaXZhdGUgbWVzc2FnZQY6BkVU--a2a1232deaf49ba164ed0d0b43b3f17cf8026c46"
    #   verifier.verify(legacy_signed_message) # => "a private message"
    #
    # Raises +InvalidSignature+ if the message was not signed with the same
    # secret or was not Base64-encoded.
    #
    #   other_verifier = ActiveSupport::MessageVerifier.new 'd1ff3r3nt-s3Krit'
    #   other_verifier.verify(signed_message) # => ActiveSupport::MessageVerifier::InvalidSignature
    #
    # Raises +InvalidClaims+ if the message doesn't have the same purpose as that
    # given in the options.
    #   verifier.verify(signed_message, for: 'something_else') # => ActiveSupport::Claims::InvalidClaims
    #
    # Raises +ExpiredClaims+ if the message is expired.
    #   expired_message = verifier.generate(value: 'a private message', expires_at: 1.day.ago)
    #   verifier.verify(signed_message) # => ActiveSupport::Claims::ExpiredClaims
    def verify(signed_message, options = {})
      if signed_message.include? "--"
        verifier = LegacyMessageVerifier.new(@secret, digest: @digest, serializer: @serializer)
        verifier.verify(signed_message)
      else
        if claims = verified(signed_message)
          Claims.verify!(claims, options)
        else
          raise InvalidSignature
        end
      end
    end

    # Generates a signed message for the given +options+ hash.
    # Choose one between +:expires_at+ and +:expires_in+
    # to set the expiry of the message.
    #
    # ==== Options
    #
    # * <tt>:value</tt> - Payload of the message.
    # * <tt>:expires_at</tt> - Expiry time of the signed message.
    # * <tt>:expires_in</tt> - Time from now after which the message
    #   will expire (e.g. 1.month).
    # * <tt>:for</tt> - Purpose of the message (defaults to 'universal').
    #
    # The message is signed with the +MessageVerifier+'s secret. Without knowing
    # the secret, the original value cannot be extracted from the message. The
    # messages are signed in the form of JSON Web Tokens (JWTs) having this format:
    # <base64-encoded header>.<base64-encoded claims>.<base64-encoded signature>
    #
    #   verifier = ActiveSupport::MessageVerifier.new 's3Krit'
    #   verifier.generate(value: 'a private message')
    #   # => "BAh7B0kiCHR5cAY6BkVUSSIISldUBjsAVEkiCGFsZwY7AFRJIglTSEExBjsAVA==.BAh7CDoIcGxkSSIWYSBwcml2YXRlIG1lc3NhZ2UGOgZFVDoIZm9ySSIOdW5pdmVyc2FsBjsGVDoIZXhwSSIdMjAxNS0wNy0yOFQxMjoxNjo0MC43OTJaBjsGVA==.MzZlYmE0ZTJjZDYyZmJiNjgyZDQxMjI4MTBkYTNkNzVhZWZmODFiZQ=="
    def generate(options)
      @claims = Claims.new(value: options[:value], **options)
      data = [encode(serialized_header), encode(serialized_claims)].join('.')
      "#{data}.#{encode(generate_digest(data))}"
    end

    private
      def header
        { 'typ' => 'JWT', 'alg' => @digest.to_s }
      end

      def serialized_header
        @serializer.dump header
      end

      def serialized_claims
        @serializer.dump @claims.to_h
      end

      def encode(data)
        ::Base64.strict_encode64(data)
      end

      def decode(data)
        ::Base64.strict_decode64(data)
      end

      def untampered?(digest, data)
        ActiveSupport::SecurityUtils.secure_compare digest, encode(generate_digest(data))
      end

      def generate_digest(data)
        require 'openssl' unless defined?(OpenSSL)
        OpenSSL::HMAC.hexdigest(OpenSSL::Digest.const_get(@digest).new, @secret, data)
      end
  end

  private
    # +LegacyMessageVerifier+ is the same implementation of the previous
    # +MessageVerifier+ to verify legacy signed messages.
    class LegacyMessageVerifier < MessageVerifier
      def valid_message?(signed_message)
        return if signed_message.nil? || !signed_message.valid_encoding? || signed_message.blank?
        
        data, digest = signed_message.split("--")
        data.present? && digest.present? && ActiveSupport::SecurityUtils.secure_compare(digest, generate_digest(data))
      end

      def verified(signed_message)
        return unless valid_message?(signed_message)

        data = signed_message.split("--").first
        @serializer.load decode(data)
      rescue ArgumentError => argument_error
        return if argument_error.message =~ %r{invalid base64}
        raise
      end

      def verify(signed_message)
        verified(signed_message) || raise(InvalidSignature)
      end

      def generate(value)
        data = encode(@serializer.dump(value))
        "#{data}--#{generate_digest(data)}"
      end
    end
end
